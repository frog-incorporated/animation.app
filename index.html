<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Mini‚ÄëAnimator</title>
  <style>
    :root {
      --panel-bg: #1e1e1e; --panel-fg: #fff; --accent: #4ade80;
      --toolbar-h: 56px;
    }
    * { box-sizing:border-box; user-select:none; -webkit-tap-highlight-color:transparent }
    body { margin:0; font-family:system-ui,Segoe UI,Roboto,sans-serif; background:#111; color:var(--panel-fg); height:100vh; display:flex; flex-direction:column }
    header { height:var(--toolbar-h); background:var(--panel-bg); display:flex; align-items:center; padding:0 .5rem; gap:.25rem; flex-wrap:wrap }
    header button, header input[type="color"], header input[type="number"] { border:none; padding:.4rem .6rem; border-radius:.5rem; background:#333; color:#fff; font-size:.9rem }
    header button.active { background:var(--accent); color:#000 }
    header input[type="number"] { width:4rem }
    main { flex:1; display:flex; flex-direction:row; overflow:hidden }
    #frames { width:120px; background:#141414; overflow-y:auto; padding:.25rem; display:flex; flex-direction:column; gap:.25rem }
    .thumb { width:100%; aspect-ratio:4/3; border:2px solid #444; cursor:grab; position:relative }
    .thumb.active { border-color:var(--accent) }
    #canvasWrap { flex:1; display:flex; justify-content:center; align-items:center; background:#222; position:relative }
    #draw { background:#fff; touch-action:none }
    #selectBox { position:absolute; border:2px dashed var(--accent); pointer-events:none; display:none }
    #onionPrev,#onionNext{position:absolute;opacity:.3;pointer-events:none;display:none}
    @media (max-width:700px){ main{flex-direction:column} #frames{flex-direction:row;width:100%;height:100px;overflow-x:auto;overflow-y:hidden} .thumb{width:100px;height:auto} }
  </style>
</head>
<body>
  <header>
    <button id="penBtn" title="Pen">‚úèÔ∏è</button>
    <button id="eraserBtn" title="Eraser">ü©π</button>
    <button id="bucketBtn" title="Paint Bucket">ü™£</button>
    <button id="selectBtn" title="Select">üî≤</button>
    <button id="undoBtn" title="Undo">‚Ü∂</button>
    <button id="addFrameBtn" title="Add Frame">‚ûï Frame</button>
    <button id="delFrameBtn" title="Delete Frame">üóëÔ∏è Frame</button>
    <button id="playBtn" title="Preview">‚ñ∂Ô∏è</button>
    <label>FPS <input id="fpsInput" type="number" min="1" max="60" value="12"></label>
    <input id="bgColor" type="color" value="#ffffff" title="Background Color" />
    <input id="bgImgInput" type="file" accept="image/*" style="display:none" />
    <button id="bgImgBtn" title="Background Image">üñºÔ∏è BG</button>

    <input id="importInput" type="file" accept="image/*" style="display:none" />
    <button id="importBtn" title="Import Image">üì• Img</button>
    <button id="saveBtn" title="Save">üíæ</button>
    <input id="loadInput" type="file" accept="application/json" style="display:none" />
    <button id="loadBtn" title="Load">üìÇ</button>
    <button id="exportBtn" title="Download mp4">üìπ</button>
  </header>

  <main>
    <div id="frames"></div>
    <div id="canvasWrap">
      <canvas id="onionPrev"></canvas>
      <canvas id="onionNext"></canvas>
      <canvas id="draw" width="800" height="600"></canvas>
      <div id="selectBox"></div>
    </div>
  </main>

  <script>
    /* ===================  Globals & State  ==================== */
    const canvas = document.getElementById('draw');
    const ctx = canvas.getContext('2d');
    const onionPrev = document.getElementById('onionPrev');
    const onionNext = document.getElementById('onionNext');
    const onionPrevCtx = onionPrev.getContext('2d');
    const onionNextCtx = onionNext.getContext('2d');
    const framesEl = document.getElementById('frames');
    const selectBox = document.getElementById('selectBox');

    let tool = 'pen';
    let drawing = false;
    let startX=0,startY=0;
    let currentFrame = 0;
    let frames = [{bg:{color:'#ffffff',img:null},layers:[ctx.getImageData(0,0,canvas.width,canvas.height)]}];
    let undoStack = [];
    let fps = 12;
    let selection = null; // {x,y,w,h,img}

    /* ===================  Utility Functions  ==================== */
    function snapshot() { // push current canvas state
      undoStack.push(canvas.toDataURL());
      if(undoStack.length>50) undoStack.shift();
    }
    function setActive(btn){ document.querySelectorAll('header button').forEach(b=>b.classList.remove('active')); if(btn) btn.classList.add('active'); }

    /* ===================  Drawing & Tools  ==================== */
    function pointerDown(e){
      const rect = canvas.getBoundingClientRect();
      const x = (e.clientX||e.touches[0].clientX) - rect.left;
      const y = (e.clientY||e.touches[0].clientY) - rect.top;
      startX=x; startY=y;
      drawing = true;
      if(tool==='pen'||tool==='eraser'){ snapshot(); ctx.beginPath(); ctx.moveTo(x,y); }
      if(tool==='select'){ selection=null; selectBox.style.display='block'; selectBox.style.left=x+'px'; selectBox.style.top=y+'px'; selectBox.style.width='0px'; selectBox.style.height='0px'; }
      if(tool==='bucket'){ snapshot(); floodFill(x,y); }
    }
    function pointerMove(e){ if(!drawing) return; const rect=canvas.getBoundingClientRect(); const x=(e.clientX||e.touches[0].clientX)-rect.left; const y=(e.clientY||e.touches[0].clientY)-rect.top;
      if(tool==='pen'){ ctx.lineTo(x,y); ctx.strokeStyle='#000'; ctx.lineWidth=2; ctx.lineCap='round'; ctx.stroke(); }
      if(tool==='eraser'){ ctx.globalCompositeOperation='destination-out'; ctx.lineTo(x,y); ctx.lineWidth=20; ctx.stroke(); ctx.globalCompositeOperation='source-over'; }
      if(tool==='select'){ const w=x-startX, h=y-startY; selectBox.style.width=Math.abs(w)+'px'; selectBox.style.height=Math.abs(h)+'px'; selectBox.style.left=(w<0?x:startX)+'px'; selectBox.style.top=(h<0?y:startY)+'px'; }
    }
    function pointerUp(e){ drawing=false; if(tool==='pen'||tool==='eraser'){ ctx.closePath(); saveFrame(); }
      if(tool==='select'){ const rect=selectBox.getBoundingClientRect(); if(rect.width>0&&rect.height>0){ selection={x:rect.left-canvas.getBoundingClientRect().left,y:rect.top-canvas.getBoundingClientRect().top,w:rect.width,h:rect.height,img:ctx.getImageData(rect.left-canvas.getBoundingClientRect().left,rect.top-canvas.getBoundingClientRect().top,rect.width,rect.height)}; }
        selectBox.style.display='none'; }
    }

    canvas.addEventListener('mousedown',pointerDown);canvas.addEventListener('mousemove',pointerMove);canvas.addEventListener('mouseup',pointerUp);
    canvas.addEventListener('touchstart',pointerDown,{passive:false});canvas.addEventListener('touchmove',pointerMove,{passive:false});canvas.addEventListener('touchend',pointerUp);

    /* ===================  Flood Fill  ==================== */
    function floodFill(x,y){ const imgData=ctx.getImageData(0,0,canvas.width,canvas.height); const data=imgData.data; const targetColor=getColorAt(x,y,data);
      const fillColor=[0,0,0,255]; if(colorsMatch(targetColor,fillColor)) return; const stack=[[x,y]]; while(stack.length){ const [cx,cy]=stack.pop(); let idx=(cy*canvas.width+cx)*4; while(cy>=0&&colorsMatch(getColorAt(cx,cy,data),targetColor)){ cy--; }
      cy++; let reachLeft=false,reachRight=false; while(cy<canvas.height&&colorsMatch(getColorAt(cx,cy,data),targetColor)){ setColorAt(cx,cy,data,fillColor); if(cx>0){ if(colorsMatch(getColorAt(cx-1,cy,data),targetColor)){ if(!reachLeft){ stack.push([cx-1,cy]); reachLeft=true; } } else reachLeft=false; }
        if(cx<canvas.width-1){ if(colorsMatch(getColorAt(cx+1,cy,data),targetColor)){ if(!reachRight){ stack.push([cx+1,cy]); reachRight=true; } } else reachRight=false; }
        cy++; idx+=canvas.width*4; }
      }
      ctx.putImageData(imgData,0,0); saveFrame(); }
    function getColorAt(x,y,data){ const idx=(y*canvas.width+x)*4; return data.slice(idx,idx+4); }
    function setColorAt(x,y,data,color){ const idx=(y*canvas.width+x)*4; for(let i=0;i<4;i++) data[idx+i]=color[i]; }
    function colorsMatch(a,b){ return a[0]==b[0]&&a[1]==b[1]&&a[2]==b[2]&&a[3]==b[3]; }

    /* ===================  Frames ==================== */
    function saveFrame(){ frames[currentFrame].layers[0]=ctx.getImageData(0,0,canvas.width,canvas.height); updateThumb(currentFrame); }
    function addFrame(){ currentFrame=frames.push({bg:{...frames[currentFrame].bg},layers:[ctx.createImageData(canvas.width,canvas.height)]})-1; drawFrame(); buildThumbs(); }
    function deleteFrame(){ if(frames.length>1){ frames.splice(currentFrame,1); currentFrame=Math.max(0,currentFrame-1); buildThumbs(); drawFrame(); } }
    function buildThumbs(){ framesEl.innerHTML=''; frames.forEach((f,i)=>{ const c=document.createElement('canvas'); c.width=160; c.height=120; const tctx=c.getContext('2d'); tctx.fillStyle=f.bg.color; tctx.fillRect(0,0,c.width,c.height); tctx.putImageData(f.layers[0],0,0); c.className='thumb'+(i===currentFrame?' active':''); c.draggable=true;
        c.addEventListener('click',()=>{ currentFrame=i; drawFrame(); buildThumbs(); }); c.addEventListener('dragstart',e=>{ e.dataTransfer.setData('text/plain',i); }); c.addEventListener('dragover',e=>e.preventDefault()); c.addEventListener('drop',e=>{ const from=+e.dataTransfer.getData('text/plain'); const to=i; const item=frames.splice(from,1)[0]; frames.splice(to,0,item); currentFrame=to; buildThumbs(); }); framesEl.appendChild(c); }); }
    function updateThumb(i){ const c=framesEl.children[i]; if(!c) return; const tctx=c.getContext('2d'); tctx.fillStyle=frames[i].bg.color; tctx.fillRect(0,0,c.width,c.height); tctx.putImageData(frames[i].layers[0],0,0); }
    function drawFrame(){ const f=frames[currentFrame]; ctx.putImageData(f.layers[0],0,0); if(f.bg.img){ ctx.drawImage(f.bg.img,0,0,canvas.width,canvas.height); } onionPrev.style.display=onionNext.style.display='none'; if(currentFrame>0){ onionPrevCtx.putImageData(frames[currentFrame-1].layers[0],0,0); onionPrev.style.display='block'; } if(currentFrame<frames.length-1){ onionNextCtx.putImageData(frames[currentFrame+1].layers[0],0,0); onionNext.style.display='block'; }
      buildThumbs(); }

    /* ===================  UI Events ==================== */
    penBtn.onclick=()=>{tool='pen';setActive(penBtn)}; eraserBtn.onclick=()=>{tool='eraser';setActive(eraserBtn)}; bucketBtn.onclick=()=>{tool='bucket';setActive(bucketBtn)}; selectBtn.onclick=()=>{tool='select';setActive(selectBtn)};
    undoBtn.onclick=()=>{ if(undoStack.length){ const img=new Image(); img.onload=()=>{ ctx.clearRect(0,0,canvas.width,canvas.height); ctx.drawImage(img,0,0); saveFrame(); }; img.src=undoStack.pop(); } };
    addFrameBtn.onclick=addFrame; delFrameBtn.onclick=deleteFrame;
    fpsInput.onchange=()=>fps=+fpsInput.value;
    playBtn.onclick=preview;
    importBtn.onclick=()=>importInput.click(); importInput.onchange=e=>{ const file=e.target.files[0]; if(!file)return; const img=new Image(); img.onload=()=>{ snapshot(); ctx.drawImage(img,0,0,canvas.width,canvas.height); saveFrame(); }; img.src=URL.createObjectURL(file); };
    bgImgBtn.onclick=()=>bgImgInput.click(); bgImgInput.onchange=e=>{ const file=e.target.files[0]; if(!file)return; const img=new Image(); img.onload=()=>{ frames[currentFrame].bg.img=img; drawFrame(); }; img.src=URL.createObjectURL(file); };
    bgColor.onchange=e=>{ frames[currentFrame].bg.color=e.target.value; drawFrame(); };
    saveBtn.onclick=()=>{ const data={frames:frames.map(f=>({bg:{color:f.bg.color,img:f.bg.img?f.bg.img.src:null},layer:canvas.toDataURL()})),fps}; const blob=new Blob([JSON.stringify(data)],{type:'application/json'}); const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download='animation.json'; a.click(); };
    loadBtn.onclick=()=>loadInput.click(); loadInput.onchange=e=>{ const file=e.target.files[0]; if(!file)return; const reader=new FileReader(); reader.onload=ev=>{ const data=JSON.parse(ev.target.result); frames=[]; Promise.all(data.frames.map(f=>new Promise(res=>{ const c=document.createElement('canvas'); c.width=canvas.width; c.height=canvas.height; const ctx2=c.getContext('2d'); const img=new Image(); img.onload=()=>{ ctx2.drawImage(img,0,0); res(ctx2.getImageData(0,0,c.width,c.height)); }; img.src=f.layer; }))).then(arr=>{ data.frames.forEach((f,i)=>{ frames[i]={bg:{color:f.bg.color,img:f.bg.img?Object.assign(new Image(),{src:f.bg.img}):null},layers:[arr[i]]}; }); currentFrame=0; fps=data.fps; fpsInput.value=fps; buildThumbs(); drawFrame(); }); }; reader.readAsText(file); };
    exportBtn.onclick=exportMP4;

    /* ===================  Preview & Export  ==================== */
    function preview(){ let idx=0; playBtn.disabled=true; const interval=setInterval(()=>{ currentFrame=idx; drawFrame(); idx=(idx+1)%frames.length; },1000/fps); setTimeout(()=>{ clearInterval(interval); playBtn.disabled=false; drawFrame(); },frames.length*1000/fps*2); }

    async function exportMP4(){ const off=document.createElement('canvas'); off.width=canvas.width; off.height=canvas.height; const offCtx=off.getContext('2d'); const stream=off.captureStream(fps); const mediaRecorder=new MediaRecorder(stream,{mimeType:'video/webm'}); const chunks=[]; mediaRecorder.ondataavailable=e=>chunks.push(e.data);
      mediaRecorder.start(); for(const f of frames){ offCtx.fillStyle=f.bg.color; offCtx.fillRect(0,0,off.width,off.height); if(f.bg.img) offCtx.drawImage(f.bg.img,0,0,off.width,off.height); offCtx.putImageData(f.layers[0],0,0); await new Promise(r=>setTimeout(r,1000/fps)); }
      mediaRecorder.stop(); mediaRecorder.onstop=()=>{ const blob=new Blob(chunks,{type:'video/webm'}); const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download='animation.webm'; a.click(); } }

    /* ===================  Service Worker Cache  ==================== */
    if('serviceWorker' in navigator){ const swCode=`self.addEventListener('install',e=>{e.waitUntil(caches.open('mini-anim').then(c=>c.addAll(['./'])))});self.addEventListener('fetch',e=>{e.respondWith(caches.match(e.request).then(r=>r||fetch(e.request)))})`; const blob=new Blob([swCode],{type:'text/javascript'}); const swUrl=URL.createObjectURL(blob); navigator.serviceWorker.register(swUrl); }

    /* ===================  Init  ==================== */
    setActive(penBtn); buildThumbs(); drawFrame();
  </script>
</body>
</html>



