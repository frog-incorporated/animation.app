<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Enhanced Animation App</title>
    <style>
        /* --- Reset & Base --- */
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        html, body {
            height: 100%;
            overflow: hidden; /* Prevent body scrollbars */
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            display: flex;
            flex-direction: column;
            background-color: #f4f7f9;
            color: #333;
            font-size: 14px;
        }

        button, input, select {
            font-family: inherit;
            font-size: inherit;
        }

        /* --- Layout --- */
        #app-container {
            display: flex;
            flex-grow: 1;
            overflow: hidden; /* Contain content */
            height: calc(100vh - 120px); /* Adjust based on combined timeline height */
        }

        #toolbar {
            width: 180px; /* Slightly wider toolbar */
            flex-shrink: 0;
            background-color: #e9edf0;
            border-right: 1px solid #d1d9e0;
            padding: 15px 10px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 15px; /* Space between sections */
        }

        #main-area {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        #canvas-container {
            flex-grow: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: #d8dfe4; /* Slightly muted background */
            overflow: auto; /* Scrollbars if canvas is larger */
            position: relative;
        }

        #drawingCanvas {
            border: 1px solid #a0a8b0;
            cursor: crosshair;
            background-color: #ffffff; /* Default canvas background */
            display: block;
            max-width: 100%; /* Ensure canvas doesn't overflow container horizontally */
            max-height: 100%;/* Ensure canvas doesn't overflow container vertically */
            object-fit: contain; /* Scale canvas down if needed, maintaining aspect ratio */
            image-rendering: pixelated; /* Keep pixels sharp */
        }

        /* Onion skin and selection canvases positioned over main canvas */
        #onionSkinCanvasUnder,
        #onionSkinCanvasOver,
        #selectionCanvas {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
            image-rendering: pixelated;
             /* Size set by JS */
        }
        #onionSkinCanvasUnder { opacity: 0.25; }
        #onionSkinCanvasOver { opacity: 0.25; }
        #selectionCanvas { border: 1px dashed #007bff; display: none; }


        #timeline-container {
            height: 120px; /* Fixed height */
            background-color: #e9edf0;
            border-top: 1px solid #d1d9e0;
            display: flex;
            align-items: center;
            padding: 10px;
            overflow-x: auto;
            overflow-y: hidden;
        }

        /* --- Toolbar Elements --- */
        .tool-section {
            padding-bottom: 10px;
            border-bottom: 1px solid #d1d9e0;
        }
        .tool-section:last-child {
            border-bottom: none;
        }

        .tool-section h4 {
            margin-bottom: 8px;
            font-size: 0.9em;
            font-weight: 600;
            color: #555;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        #toolbar button,
        .timeline-control button, /* Target timeline controls */
        #file-controls button,
        #background-controls button {
            display: flex; /* Align icon/text */
            align-items: center;
            justify-content: center;
            gap: 5px; /* Space between icon/text */
            width: 100%;
            padding: 8px 10px;
            margin-bottom: 6px;
            background-color: #fff;
            border: 1px solid #c5ced6;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.95em;
            text-align: center;
            transition: background-color 0.2s ease, border-color 0.2s ease;
        }

        #toolbar button:hover,
        .timeline-control button:hover,
        #file-controls button:hover,
        #background-controls button:hover {
            background-color: #f8f9fa;
            border-color: #a0a8b0;
        }

        #toolbar button.active {
            background-color: #d1e7ff;
            border-color: #a6cfff;
            font-weight: 600;
            color: #0056b3;
        }

        #toolbar button:disabled,
        .timeline-control button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            background-color: #e9ecef;
        }


        #toolbar input[type="color"],
        #toolbar input[type="range"],
        #toolbar input[type="number"],
        #toolbar input[type="file"],
        #background-controls input[type="color"] {
            width: 100%;
            margin-bottom: 8px;
            padding: 5px;
            border: 1px solid #c5ced6;
            border-radius: 4px;
        }
        #toolbar input[type="color"] {
            height: 30px;
            padding: 2px; /* Adjust padding for color input */
        }
        #toolbar input[type="file"] {
             display: none; /* Hide default file input */
        }

        #toolbar label, #background-controls label {
            display: block;
            font-size: 0.85em;
            margin-bottom: 4px;
            color: #555;
            font-weight: 500;
        }
         .inline-label { display: inline-block; margin-right: 5px; }


         #brush-size-container { display: flex; align-items: center; gap: 5px; margin-bottom: 8px;}
         #brush-size { flex-grow: 1; }
         #brush-size-label { font-size: 0.9em; min-width: 20px; text-align: right; }


        /* --- Timeline Elements --- */
        #timeline-controls {
            display: flex;
            flex-direction: column; /* Stack buttons vertically */
            justify-content: center; /* Center buttons */
            padding-right: 10px;
            margin-right: 10px;
            border-right: 1px solid #d1d9e0;
            height: 100%;
        }
         .timeline-control button {
            width: 90px; /* Adjust width as needed */
            height: 30px;
            padding: 5px;
            font-size: 0.85em;
            margin-bottom: 5px;
         }
         .timeline-control button:last-child { margin-bottom: 0; }


         #frames {
            display: flex;
            height: 100%;
            align-items: center;
            gap: 8px; /* Space between frames */
            padding-bottom: 5px; /* Prevent scrollbar overlap */
         }
        .frame {
            border: 2px solid #a0a8b0;
            width: 100px;
            height: 80px;
            cursor: pointer;
            position: relative;
            background-color: #fff; /* Base background for thumbnail */
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            flex-shrink: 0;
            border-radius: 3px;
            overflow: hidden; /* Clip content like delete button */
             display: flex; /* Center potential placeholder text */
            justify-content: center;
            align-items: center;
            transition: border-color 0.2s ease;
        }
        .frame:hover {
             border-color: #007bff;
        }
        .frame.active-frame {
            border-color: #0056b3;
            box-shadow: 0 0 0 2px rgba(0, 86, 179, 0.5);
        }
         .frame-number {
             position: absolute;
             bottom: 3px;
             right: 5px;
             background-color: rgba(0, 0, 0, 0.65);
             color: white;
             font-size: 0.75em;
             padding: 1px 4px;
             border-radius: 3px;
         }
         .delete-frame {
            position: absolute;
            top: 2px;
            right: 2px;
            width: 18px;
            height: 18px;
            background-color: rgba(220, 53, 69, 0.8); /* Red */
            color: white;
            border: none;
            border-radius: 50%;
            font-size: 12px;
            line-height: 18px;
            text-align: center;
            cursor: pointer;
            opacity: 0; /* Hidden by default */
            transition: opacity 0.2s ease;
         }
         .frame:hover .delete-frame {
             opacity: 1;
         }
         .delete-frame:hover {
             background-color: rgba(200, 33, 49, 1);
         }


        /* --- Playback & Other Controls --- */
         #playback-controls, #background-controls, #file-controls, #onion-skin-controls {
             display: flex;
             flex-wrap: wrap; /* Allow wrapping if needed */
             align-items: center;
             gap: 8px; /* Spacing between items */
         }
         #playback-controls label, #background-controls label, #onion-skin-controls label {
             font-size: 0.85em;
             white-space: nowrap;
         }
         #playback-controls input[type="number"],
         #onion-skin-controls input[type="number"] {
             width: 55px;
             padding: 4px;
         }
         #background-controls input[type="color"] { width: 40px; height: 30px; padding: 1px; margin-bottom: 0; }
         #background-controls button { width: auto; padding: 6px 10px; font-size: 0.9em; margin-bottom: 0; }

         /* Status message */
         #export-status {
            font-size: 0.85em;
            color: #0056b3;
            margin-top: 5px;
            min-height: 1.2em; /* Reserve space */
         }


        /* --- Mobile Adjustments --- */
        @media (max-width: 768px) {
             html, body { height: auto; overflow: visible; } /* Allow scrolling on mobile */
            #app-container {
                flex-direction: column;
                height: auto;
            }
            #toolbar {
                width: 100%;
                order: 1; /* Toolbar below canvas */
                border-right: none;
                border-top: 1px solid #d1d9e0; /* Border on top now */
                flex-direction: row; /* Horizontal scroll */
                flex-wrap: nowrap; /* Prevent wrapping */
                overflow-x: auto;
                padding: 5px;
                gap: 10px;
            }
            #toolbar .tool-section {
                 flex-shrink: 0; /* Prevent sections from shrinking */
                 padding-bottom: 0;
                 border-bottom: none;
                 margin-bottom: 0;
            }
            #toolbar .tool-section h4 { display: none; } /* Hide titles */
            #toolbar button { width: auto; font-size: 0.9em; padding: 6px 8px; }
            #toolbar label { display: none; } /* Hide most labels */
            #toolbar input[type="color"] { width: 35px; height: 30px; }
             #brush-size-container { width: 100px; margin-bottom: 0;}

            #main-area {
                order: 0; /* Canvas first */
                 height: calc(60vh); /* Example height, adjust as needed */
            }
            #timeline-container {
                order: 2; /* Timeline last */
                height: 100px;
            }
            .frame {
                width: 80px;
                height: 60px;
            }
             .timeline-control button { width: 80px; }
        }
    </style>
</head>
<body>

    <div id="app-container">
        <div id="toolbar">
            <div class="tool-section">
                <h4>Tools</h4>
                <button id="pen-tool" class="tool active" title="Pen (P)">✏️ Pen</button>
                <button id="eraser-tool" class="tool" title="Eraser (E)">🧼 Eraser</button>
                <button id="paint-bucket-tool" class="tool" title="Paint Bucket (B)">🩸 Bucket</button>
                <button id="select-tool" class="tool" title="Select Tool (S) - Basic Box">✂️ Select</button>
                <button id="undo-button" title="Undo (Ctrl+Z)">↩️ Undo</button>
            </div>

            <div class="tool-section">
                <h4>Options</h4>
                <label for="color-picker">Color:</label>
                <input type="color" id="color-picker" value="#000000" title="Drawing Color">
                 <label for="brush-size">Size:</label>
                 <div id="brush-size-container">
                    <input type="range" id="brush-size" min="1" max="100" value="5" title="Brush Size">
                    <span id="brush-size-label">5</span>
                 </div>
            </div>

             <div class="tool-section">
                <h4>Playback & Export</h4>
                 <div id="playback-controls">
                    <button id="play-pause-button" title="Play/Pause Animation">▶️ Play</button>
                    <label for="fps-input" class="inline-label">FPS:</label>
                    <input type="number" id="fps-input" value="12" min="1" max="60">
                </div>
                <button id="export-video-button" title="Export Animation as WebM Video">🎬 Export Video</button>
                <div id="export-status"></div>
            </div>

            <div class="tool-section">
                <h4>Background</h4>
                 <div id="background-controls">
                    <label for="bg-color-picker" class="inline-label">Color:</label>
                    <input type="color" id="bg-color-picker" value="#FFFFFF" title="Background Color">
                    <button id="set-bg-color">Set</button>
                    <input type="file" id="bg-image-upload" accept="image/*">
                    <button onclick="document.getElementById('bg-image-upload').click();" title="Upload Background Image">🖼️ Upload</button>
                 </div>
            </div>

             <div class="tool-section">
                <h4>Project</h4>
                <div id="file-controls">
                    <button id="save-button" title="Save Project File (.animproj)">💾 Save</button>
                     <input type="file" id="load-input" accept=".json, .animproj">
                     <button onclick="document.getElementById('load-input').click();" title="Load Project File">📂 Load</button>
                     <input type="file" id="import-image-upload" accept="image/*">
                     <button onclick="document.getElementById('import-image-upload').click();" title="Import Image to Current Frame">📥 Import</button>
                 </div>
            </div>

             <div class="tool-section">
                 <h4>Onion Skin</h4>
                 <div id="onion-skin-controls">
                    <label for="onion-skin-before" class="inline-label">Before:</label>
                    <input type="number" id="onion-skin-before" value="1" min="0" max="5">
                    <label for="onion-skin-after" class="inline-label">After:</label>
                    <input type="number" id="onion-skin-after" value="1" min="0" max="5">
                </div>
             </div>

        </div> {/* */}

        <div id="main-area">
            <div id="canvas-container">
                <canvas id="onionSkinCanvasUnder"></canvas>
                <canvas id="drawingCanvas"></canvas> {/* Main drawing canvas */}
                <canvas id="onionSkinCanvasOver"></canvas>
                <canvas id="selectionCanvas"></canvas> {/* For selection box visual */}
            </div>
        </div> {/* */}
    </div> {/* */}

    <div id="timeline-container">
        <div id="timeline-controls">
            <div class="timeline-control"> <button id="add-frame-button" title="Add New Frame After Current">➕ Add</button> </div>
            <div class="timeline-control"> <button id="duplicate-frame-button" title="Duplicate Current Frame">📋 Duplicate</button> </div>
            <div class="timeline-control"> <button id="delete-frame-button" title="Delete Current Frame">🗑️ Delete</button> </div>
        </div>
        <div id="frames">
            {/* Frame thumbnails will be added here by JS */}
        </div>
    </div> {/* */}

    <script>
        // --- Globals & Constants ---
        const canvas = document.getElementById('drawingCanvas');
        const ctx = canvas.getContext('2d', { willReadFrequently: true }); // willReadFrequently for getImageData performance
        const onionCanvasUnder = document.getElementById('onionSkinCanvasUnder');
        const ctxOnionUnder = onionCanvasUnder.getContext('2d');
        const onionCanvasOver = document.getElementById('onionSkinCanvasOver');
        const ctxOnionOver = onionCanvasOver.getContext('2d');
        const selectionCanvas = document.getElementById('selectionCanvas');
        const ctxSelection = selectionCanvas.getContext('2d');

        const MAX_UNDO_STEPS = 30; // Increased undo steps

        // --- State Variables ---
        let currentTool = 'pen';
        let isDrawing = false;
        let isSelecting = false;
        let lastX = 0;
        let lastY = 0;
        let brushSize = 5;
        let currentColor = '#000000';
        let backgroundColor = '#FFFFFF';
        let backgroundImage = null;
        let frames = []; // Stores ImageData objects
        let currentFrameIndex = 0;
        let undoStack = [];
        let fps = 12;
        let isPlaying = false;
        let animationInterval = null;
        let onionSkinBefore = 1;
        let onionSkinAfter = 1;
        let selectionRect = { x: 0, y: 0, w: 0, h: 0 };
        let selectionActive = false;
        let mediaRecorder = null;
        let recordedChunks = [];

        // --- Initialization ---
        function initialize() {
            console.log("Initializing Animation App...");
            resizeCanvas();
            frames = [createBlankImageData()];
            currentFrameIndex = 0;
            loadFrame(currentFrameIndex);
            updateTimeline();
            setActiveFrame(currentFrameIndex);
            setupUI();
            setupEventListeners();
            console.log("Initialization Complete.");
        }

        function setupUI() {
            document.getElementById('pen-tool').classList.add('active');
            document.getElementById('brush-size').value = brushSize;
            document.getElementById('brush-size-label').textContent = brushSize;
            document.getElementById('color-picker').value = currentColor;
            document.getElementById('fps-input').value = fps;
            document.getElementById('bg-color-picker').value = backgroundColor;
            document.getElementById('onion-skin-before').value = onionSkinBefore;
            document.getElementById('onion-skin-after').value = onionSkinAfter;
            document.getElementById('undo-button').disabled = true;
        }

        function createBlankImageData() {
            return ctx.createImageData(canvas.width, canvas.height);
        }

        // --- Canvas & Context ---
        function resizeCanvas() {
            const container = document.getElementById('canvas-container');
            // Maintain a fixed aspect ratio (e.g., 4:3) or use fixed dimensions
            const aspectRatio = 4 / 3;
            let newWidth = container.clientWidth - 40; // Some padding
            let newHeight = container.clientHeight - 40;

            if (newWidth / newHeight > aspectRatio) {
                newWidth = newHeight * aspectRatio;
            } else {
                newHeight = newWidth / aspectRatio;
            }
            newWidth = Math.max(100, Math.floor(newWidth)); // Min size
            newHeight = Math.max(75, Math.floor(newHeight));

             // Set internal resolution
             canvas.width = newWidth;
             canvas.height = newHeight;
             onionCanvasUnder.width = newWidth;
             onionCanvasUnder.height = newHeight;
             onionCanvasOver.width = newWidth;
             onionCanvasOver.height = newHeight;
             selectionCanvas.width = newWidth;
             selectionCanvas.height = newHeight;

             // Set display size (CSS handles scaling via max-width/height)
             canvas.style.width = `${newWidth}px`;
             canvas.style.height = `${newHeight}px`;
             onionCanvasUnder.style.width = `${newWidth}px`;
             onionCanvasUnder.style.height = `${newHeight}px`;
             onionCanvasOver.style.width = `${newWidth}px`;
             onionCanvasOver.style.height = `${newHeight}px`;
             selectionCanvas.style.width = `${newWidth}px`;
             selectionCanvas.style.height = `${newHeight}px`;

            // Re-render after resize
             if (frames.length > 0) {
                 // Optional: Resize existing frame data (complex, involves resampling)
                 // Simple approach: Just reload current frame (may clear if size changed drastically)
                 loadFrame(currentFrameIndex);
                 drawOnionSkins();
             }
             // Recalculate positions of overlay canvases (needed if container size changes)
             positionOverlayCanvases();
        }

        function positionOverlayCanvases() {
            // This ensures overlays are centered correctly, especially after resize
            const rect = canvas.getBoundingClientRect(); // Use main canvas position
            const containerRect = document.getElementById('canvas-container').getBoundingClientRect();

             const topOffset = rect.top - containerRect.top;
             const leftOffset = rect.left - containerRect.left;

             [onionCanvasUnder, onionCanvasOver, selectionCanvas].forEach(overlay => {
                 overlay.style.top = `${topOffset}px`;
                 overlay.style.left = `${leftOffset}px`;
                 overlay.style.transform = 'none'; // Reset transform if using top/left positioning
             });
        }


        function clearCanvas(targetCtx = ctx) {
            targetCtx.clearRect(0, 0, targetCtx.canvas.width, targetCtx.canvas.height);
        }

        function drawBackground(targetCtx = ctx) {
            if (backgroundImage) {
                targetCtx.drawImage(backgroundImage, 0, 0, targetCtx.canvas.width, targetCtx.canvas.height);
            } else {
                targetCtx.fillStyle = backgroundColor;
                targetCtx.fillRect(0, 0, targetCtx.canvas.width, targetCtx.canvas.height);
            }
        }

        // --- Drawing Logic ---
        function getCanvasPos(evt) {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            let clientX, clientY;

            if (evt.touches && evt.touches.length > 0) {
                clientX = evt.touches[0].clientX;
                clientY = evt.touches[0].clientY;
            } else {
                clientX = evt.clientX;
                clientY = evt.clientY;
            }

            return {
                x: Math.floor((clientX - rect.left) * scaleX),
                y: Math.floor((clientY - rect.top) * scaleY)
            };
        }

        function startAction(e) {
            e.preventDefault(); // Prevent unwanted default actions (like text selection)
            const pos = getCanvasPos(e);

             if (currentTool === 'select') {
                 isSelecting = true;
                 selectionActive = false;
                 selectionRect.x = pos.x;
                 selectionRect.y = pos.y;
                 selectionRect.w = 0;
                 selectionRect.h = 0;
                 selectionCanvas.style.display = 'block';
                 drawSelectionRectangle();
             } else if (currentTool === 'paint-bucket') {
                  saveUndoState(); // Save state BEFORE filling
                  paintBucketFill(pos.x, pos.y);
                  saveCurrentFrameData(); // Store modified data
                  saveCurrentFrameThumbnail(); // Update thumbnail
             } else { // Pen or Eraser
                 saveUndoState();
                 isDrawing = true;
                 [lastX, lastY] = [pos.x, pos.y];
                 draw(e); // Draw a dot on initial click
             }
        }

        function performAction(e) {
             if (!isDrawing && !isSelecting) return;
             e.preventDefault(); // Prevent scrolling on touch devices while drawing/selecting
             const pos = getCanvasPos(e);

            if (isDrawing) {
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                ctx.globalCompositeOperation = (currentTool === 'eraser') ? 'destination-out' : 'source-over';
                ctx.strokeStyle = (currentTool === 'eraser') ? 'rgba(0,0,0,1)' : currentColor; // Eraser needs opaque color for destination-out
                ctx.lineWidth = brushSize;

                ctx.beginPath();
                ctx.moveTo(lastX, lastY);
                ctx.lineTo(pos.x, pos.y);
                ctx.stroke();
                [lastX, lastY] = [pos.x, pos.y];
            } else if (isSelecting) {
                selectionRect.w = pos.x - selectionRect.x;
                selectionRect.h = pos.y - selectionRect.y;
                drawSelectionRectangle();
            }
        }

        function endAction(e) {
            if (isDrawing) {
                isDrawing = false;
                ctx.globalCompositeOperation = 'source-over'; // Reset blend mode
                saveCurrentFrameData(); // Save drawn data
                saveCurrentFrameThumbnail();
            }
            if (isSelecting) {
                isSelecting = false;
                const normRect = getNormalizedSelectionRect();
                if (normRect.w > 2 && normRect.h > 2) { // Require minimal size
                     selectionActive = true;
                     console.log("Selection Area (basic):", normRect);
                     // Basic selection box is drawn. Full manipulation not implemented.
                 } else {
                     clearSelectionRectangle(); // Clear if selection too small
                 }
            }
        }

        // --- Selection Tool ---
        function drawSelectionRectangle() {
            clearCanvas(ctxSelection);
            const rect = getNormalizedSelectionRect();
            ctxSelection.setLineDash([4, 2]);
            ctxSelection.strokeStyle = '#007bff';
            ctxSelection.lineWidth = 1;
            ctxSelection.strokeRect(rect.x + 0.5, rect.y + 0.5, rect.w, rect.h); // Offset by 0.5 for sharper lines
        }

        function clearSelectionRectangle() {
            clearCanvas(ctxSelection);
            selectionCanvas.style.display = 'none';
            selectionActive = false;
        }

        function getNormalizedSelectionRect() {
            let x = selectionRect.x;
            let y = selectionRect.y;
            let w = selectionRect.w;
            let h = selectionRect.h;
            if (w < 0) { x += w; w = -w; }
            if (h < 0) { y += h; h = -h; }
            return { x, y, w, h };
        }

        // --- Paint Bucket ---
        // Helper: Convert hex color string to RGBA array [r, g, b, a]
        function hexToRgba(hex) {
            if (!hex) return [0, 0, 0, 0]; // Handle null/empty case
            hex = hex.replace('#', '');
            const r = parseInt(hex.slice(0, 2), 16);
            const g = parseInt(hex.slice(2, 4), 16);
            const b = parseInt(hex.slice(4, 6), 16);
            return [r, g, b, 255]; // Assume full alpha
        }

        // Helper: Get RGBA color of a pixel from ImageData
        function getPixelColor(imageData, x, y) {
            if (x < 0 || x >= imageData.width || y < 0 || y >= imageData.height) {
                return [-1, -1, -1, -1]; // Out of bounds
            }
            const offset = (y * imageData.width + x) * 4;
            return [
                imageData.data[offset],
                imageData.data[offset + 1],
                imageData.data[offset + 2],
                imageData.data[offset + 3]
            ];
        }

        // Helper: Set RGBA color of a pixel in ImageData
        function setPixelColor(imageData, x, y, color) {
            const offset = (y * imageData.width + x) * 4;
            imageData.data[offset] = color[0];
            imageData.data[offset + 1] = color[1];
            imageData.data[offset + 2] = color[2];
            imageData.data[offset + 3] = color[3];
        }

        // Helper: Check if two colors match (simple exact match)
         function colorsMatch(color1, color2) {
             // Basic exact match. Could add tolerance later.
             return color1[0] === color2[0] &&
                    color1[1] === color2[1] &&
                    color1[2] === color2[2] &&
                    color1[3] === color2[3];
         }

        // Paint Bucket fill using Scan-line algorithm
        function paintBucketFill(startX, startY) {
             console.time("FloodFill"); // Start timing
            const imgData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const width = imgData.width;
            const height = imgData.height;
            const targetColor = getPixelColor(imgData, startX, startY);
            const fillColor = hexToRgba(currentColor);

             // Handle edge cases
             if (targetColor[0] === -1) { console.warn("Fill start is out of bounds"); return; } // Clicked outside
             if (colorsMatch(targetColor, fillColor)) { console.log("Target and fill colors are the same."); return; } // Nothing to fill

            const stack = [[startX, startY]];
            const visited = new Uint8Array(width * height); // Use Uint8Array as a boolean flag (0 or 1)

            while (stack.length > 0) {
                const [x, y] = stack.pop();
                let currentY = y;

                // Move up until we are above the fill area or hit the top
                while (currentY >= 0 && colorsMatch(getPixelColor(imgData, x, currentY), targetColor)) {
                    currentY--;
                }
                currentY++; // Move back into the fill area

                let spanLeft = false;
                let spanRight = false;

                // Scan down, filling and checking neighbors
                 while (currentY < height && colorsMatch(getPixelColor(imgData, x, currentY), targetColor)) {
                     const pixelIndex = currentY * width + x;
                     if (visited[pixelIndex] === 0) { // Check if visited *before* coloring
                         setPixelColor(imgData, x, currentY, fillColor);
                         visited[pixelIndex] = 1; // Mark as visited

                         // Check left neighbor
                         if (x > 0) {
                             const leftColor = getPixelColor(imgData, x - 1, currentY);
                              const leftIndex = currentY * width + (x - 1);
                             if (colorsMatch(leftColor, targetColor) && visited[leftIndex] === 0) {
                                 if (!spanLeft) {
                                     stack.push([x - 1, currentY]);
                                     spanLeft = true;
                                 }
                             } else if (spanLeft) {
                                 spanLeft = false;
                             }
                         }

                         // Check right neighbor
                         if (x < width - 1) {
                             const rightColor = getPixelColor(imgData, x + 1, currentY);
                             const rightIndex = currentY * width + (x + 1);
                             if (colorsMatch(rightColor, targetColor) && visited[rightIndex] === 0) {
                                 if (!spanRight) {
                                     stack.push([x + 1, currentY]);
                                     spanRight = true;
                                 }
                             } else if (spanRight) {
                                 spanRight = false;
                             }
                         }
                     }
                     currentY++;
                 }
            }

            // Put the modified data back onto the canvas
            ctx.putImageData(imgData, 0, 0);
             console.timeEnd("FloodFill"); // End timing
        }


        // --- Undo Logic ---
        function saveUndoState() {
             if (undoStack.length >= MAX_UNDO_STEPS) {
                 undoStack.shift();
             }
             undoStack.push(ctx.getImageData(0, 0, canvas.width, canvas.height));
             document.getElementById('undo-button').disabled = false;
        }

        function undo() {
            if (undoStack.length > 0) {
                const prevState = undoStack.pop();
                clearCanvas();
                drawBackground(); // Redraw background
                ctx.putImageData(prevState, 0, 0); // Restore previous drawing state
                saveCurrentFrameData(); // Update frame data storage
                saveCurrentFrameThumbnail();
            }
            document.getElementById('undo-button').disabled = undoStack.length === 0;
        }


        // --- Frame Management ---
        function addFrame() {
            saveCurrentFrameData();
            frames.splice(currentFrameIndex + 1, 0, createBlankImageData());
            currentFrameIndex++;
            loadFrame(currentFrameIndex);
            updateTimeline();
            setActiveFrame(currentFrameIndex);
            clearUndoStack();
        }

        function duplicateFrame() {
            saveCurrentFrameData(); // Save current first
            if (currentFrameIndex < 0 || currentFrameIndex >= frames.length) return;

            const currentImageData = frames[currentFrameIndex];
            // Create a true copy of the ImageData
             const duplicateImageData = ctx.createImageData(currentImageData.width, currentImageData.height);
             duplicateImageData.data.set(currentImageData.data);

            frames.splice(currentFrameIndex + 1, 0, duplicateImageData); // Insert copy after current
            currentFrameIndex++;
            loadFrame(currentFrameIndex); // Load the new duplicate frame
            updateTimeline();
            setActiveFrame(currentFrameIndex);
            clearUndoStack();
        }

        function deleteFrame(indexToDelete) {
            if (frames.length <= 1) {
                alert("Cannot delete the last frame!"); return;
            }
            if (!confirm(`Delete frame ${indexToDelete + 1}? This cannot be undone.`)) return;

            frames.splice(indexToDelete, 1);
            currentFrameIndex = Math.min(Math.max(0, currentFrameIndex), frames.length - 1); // Adjust index carefully
            if (currentFrameIndex >= indexToDelete && indexToDelete > 0) {
                 currentFrameIndex = indexToDelete - 1; // Prefer selecting previous frame
            } else {
                 currentFrameIndex = 0; // Default to first if deleting first
            }

            loadFrame(currentFrameIndex);
            updateTimeline();
            setActiveFrame(currentFrameIndex);
            clearUndoStack();
        }

        function selectFrame(index) {
            if (index === currentFrameIndex || index < 0 || index >= frames.length) return;
            saveCurrentFrameData(); // Save frame we are leaving
            currentFrameIndex = index;
            loadFrame(currentFrameIndex);
            setActiveFrame(index);
            clearUndoStack(); // Clear undo when switching frames
        }

         function clearUndoStack() {
             undoStack = [];
             document.getElementById('undo-button').disabled = true;
         }

        function saveCurrentFrameData() {
             if (currentFrameIndex >= 0 && currentFrameIndex < frames.length) {
                 frames[currentFrameIndex] = ctx.getImageData(0, 0, canvas.width, canvas.height);
             }
        }

        function loadFrame(index) {
            if (index < 0 || index >= frames.length) return;
            clearCanvas();
            drawBackground(); // Draw background first
            const frameData = frames[index];
            if (frameData instanceof ImageData) {
                ctx.putImageData(frameData, 0, 0);
            }
            currentFrameIndex = index;
            drawOnionSkins();
            clearSelectionRectangle();
        }


        // --- Timeline UI ---
        function updateTimeline() {
            const framesContainer = document.getElementById('frames');
            framesContainer.innerHTML = ''; // Clear

            frames.forEach((frameData, index) => {
                const frameDiv = document.createElement('div');
                frameDiv.className = 'frame';
                frameDiv.dataset.index = index;

                const frameNumber = document.createElement('span');
                frameNumber.className = 'frame-number';
                frameNumber.textContent = index + 1;

                const deleteBtn = document.createElement('button');
                deleteBtn.className = 'delete-frame';
                deleteBtn.innerHTML = '&times;';
                deleteBtn.title = `Delete Frame ${index + 1}`;
                deleteBtn.onclick = (e) => {
                    e.stopPropagation(); deleteFrame(index);
                };

                frameDiv.appendChild(frameNumber);
                frameDiv.appendChild(deleteBtn);
                frameDiv.addEventListener('click', () => selectFrame(index));

                generateThumbnail(frameData, frameDiv); // Generate and set thumbnail bg
                framesContainer.appendChild(frameDiv);
            });

             document.getElementById('delete-frame-button').disabled = frames.length <= 1;
             setActiveFrame(currentFrameIndex); // Re-apply active state
        }

        function generateThumbnail(frameData, frameDiv) {
            const thumbCanvas = document.createElement('canvas');
            const thumbCtx = thumbCanvas.getContext('2d');
            const thumbSize = 80; // Base size for thumbnail rendering
            thumbCanvas.width = thumbSize * (canvas.width / canvas.height);
            thumbCanvas.height = thumbSize;

            // Draw background for thumbnail
             drawBackground(thumbCtx); // Use helper to draw background on thumb canvas

            // Draw frame content onto thumbnail canvas (scaled)
            if (frameData instanceof ImageData) {
                 // Draw ImageData to an intermediate canvas, then draw that scaled
                 const tempFrameCanvas = document.createElement('canvas');
                 tempFrameCanvas.width = frameData.width;
                 tempFrameCanvas.height = frameData.height;
                 tempFrameCanvas.getContext('2d').putImageData(frameData, 0, 0);
                 thumbCtx.drawImage(tempFrameCanvas, 0, 0, thumbCanvas.width, thumbCanvas.height);
            }

            frameDiv.style.backgroundImage = `url(${thumbCanvas.toDataURL()})`;
            frameDiv.style.backgroundSize = 'contain';
            frameDiv.style.backgroundRepeat = 'no-repeat';
            frameDiv.style.backgroundPosition = 'center';
        }

        function saveCurrentFrameThumbnail() {
            const frameDiv = document.querySelector(`.frame[data-index="${currentFrameIndex}"]`);
            if (frameDiv && currentFrameIndex >= 0 && currentFrameIndex < frames.length) {
                 generateThumbnail(frames[currentFrameIndex], frameDiv);
            }
        }

        function setActiveFrame(index) {
            document.querySelectorAll('.frame').forEach(f => f.classList.remove('active-frame'));
            const activeFrameDiv = document.querySelector(`.frame[data-index="${index}"]`);
            if (activeFrameDiv) {
                activeFrameDiv.classList.add('active-frame');
                 // Scroll into view smoothly
                 activeFrameDiv.scrollIntoView({ behavior: 'smooth', block: 'nearest', inline: 'center' });
            }
        }

        // --- Onion Skinning ---
         function drawOnionSkins() {
             clearCanvas(ctxOnionUnder);
             clearCanvas(ctxOnionOver);

             // Draw previous frames
             drawOnionSkinLayer(ctxOnionUnder, currentFrameIndex - 1, onionSkinBefore, -1, 'blue');
             // Draw next frames
             drawOnionSkinLayer(ctxOnionOver, currentFrameIndex + 1, onionSkinAfter, 1, 'red');
         }

         function drawOnionSkinLayer(onionCtx, startIndex, count, direction, tint) {
             const tempOnionCanvas = document.createElement('canvas');
             tempOnionCanvas.width = canvas.width;
             tempOnionCanvas.height = canvas.height;
             const tempOnionCtx = tempOnionCanvas.getContext('2d');

             onionCtx.globalAlpha = 0.5; // Adjust base opacity as needed

             for (let i = 0; i < count; i++) {
                 const frameIndex = startIndex + (i * direction);
                 if (frameIndex >= 0 && frameIndex < frames.length) {
                     const frameData = frames[frameIndex];
                     if (frameData instanceof ImageData) {
                          // Draw frame data to temporary canvas
                         tempOnionCtx.putImageData(frameData, 0, 0);

                          // Apply tint by compositing
                         tempOnionCtx.globalCompositeOperation = 'source-atop';
                         tempOnionCtx.fillStyle = tint;
                         tempOnionCtx.fillRect(0, 0, tempOnionCanvas.width, tempOnionCanvas.height);
                         tempOnionCtx.globalCompositeOperation = 'source-over'; // Reset

                         // Draw tinted frame onto the actual onion skin canvas
                         onionCtx.drawImage(tempOnionCanvas, 0, 0);

                         // Optional: Decrease opacity further for frames farther away
                         // onionCtx.globalAlpha *= 0.7;

                         // Clear temporary canvas for next frame
                         clearCanvas(tempOnionCtx);
                     }
                 } else {
                     break;
                 }
             }
             onionCtx.globalAlpha = 1.0; // Reset alpha
         }


        // --- Animation Playback ---
        function playPauseAnimation() {
            if (isPlaying) {
                clearInterval(animationInterval);
                isPlaying = false;
                document.getElementById('play-pause-button').innerHTML = '▶️ Play';
                document.getElementById('play-pause-button').title = 'Play Animation';
                // Re-enable controls disabled during playback
                 enableControls();
            } else {
                isPlaying = true;
                saveCurrentFrameData(); // Save any pending changes before playback
                document.getElementById('play-pause-button').innerHTML = '❚❚ Pause';
                 document.getElementById('play-pause-button').title = 'Pause Animation';
                 // Disable controls during playback
                 disableControls();

                let playbackFrameIndex = 0; // Always start from beginning for playback loop
                loadFrame(playbackFrameIndex); // Show first frame immediately
                setActiveFrame(playbackFrameIndex);

                animationInterval = setInterval(() => {
                    playbackFrameIndex = (playbackFrameIndex + 1) % frames.length; // Loop
                    loadFrame(playbackFrameIndex);
                    setActiveFrame(playbackFrameIndex);
                }, 1000 / fps);
            }
        }

         function disableControls() {
             // Disable buttons that shouldn't be used during playback/export
             document.querySelectorAll('#toolbar button, #timeline-controls button, #file-controls button, #background-controls button').forEach(btn => btn.disabled = true);
             document.querySelectorAll('#toolbar input, #background-controls input').forEach(input => input.disabled = true);
             document.getElementById('play-pause-button').disabled = false; // Keep play/pause enabled
             document.getElementById('export-video-button').disabled = true; // Disable export while playing
         }

         function enableControls() {
             document.querySelectorAll('#toolbar button, #timeline-controls button, #file-controls button, #background-controls button').forEach(btn => btn.disabled = false);
              document.querySelectorAll('#toolbar input, #background-controls input').forEach(input => input.disabled = false);
             // Re-apply specific disabled states
             document.getElementById('undo-button').disabled = undoStack.length === 0;
             document.getElementById('delete-frame-button').disabled = frames.length <= 1;
             document.getElementById('export-video-button').disabled = false; // Re-enable export
         }


        function updateFps(newFps) {
             fps = Math.max(1, parseInt(newFps) || 1);
             document.getElementById('fps-input').value = fps;
             if (isPlaying) { // Restart playback with new FPS
                 playPauseAnimation(); playPauseAnimation();
             }
        }

        // --- Background Handling ---
        function setBackgroundColor(color) {
            backgroundColor = color;
            backgroundImage = null;
            document.getElementById('bg-color-picker').value = color;
            loadFrame(currentFrameIndex); // Reload frame with new background
            updateTimeline(); // Update all thumbnails
        }

        function setBackgroundImage(file) {
             const reader = new FileReader();
             reader.onload = function(e) {
                 const img = new Image();
                 img.onload = () => {
                     backgroundImage = img;
                     backgroundColor = '#FFFFFF'; // Clear color background
                     loadFrame(currentFrameIndex);
                     updateTimeline();
                 };
                 img.onerror = () => alert("Failed to load background image.");
                 img.src = e.target.result;
             }
             reader.onerror = () => alert("Failed to read image file.");
             reader.readAsDataURL(file);
        }

        // --- Image Import ---
         function importImage(file) {
             if (currentFrameIndex < 0 || currentFrameIndex >= frames.length) return;
             const reader = new FileReader();
             reader.onload = function(event) {
                 const img = new Image();
                 img.onload = () => {
                      saveUndoState();
                     // Draw centered or allow user placement later
                      const scale = Math.min(canvas.width / img.width, canvas.height / img.height, 1);
                      const drawWidth = img.width * scale;
                      const drawHeight = img.height * scale;
                      const drawX = (canvas.width - drawWidth) / 2;
                      const drawY = (canvas.height - drawHeight) / 2;
                     ctx.drawImage(img, drawX, drawY, drawWidth, drawHeight);
                     saveCurrentFrameData();
                     saveCurrentFrameThumbnail();
                 };
                 img.onerror = () => alert("Failed to load image for import.");
                 img.src = event.target.result;
             }
             reader.onerror = () => alert("Failed to read image file for import.");
             reader.readAsDataURL(file);
         }

        // --- Save/Load Project ---
        function saveProject() {
            saveCurrentFrameData(); // Ensure current frame is saved
            const serializableFrames = frames.map(imageData => {
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = imageData.width;
                tempCanvas.height = imageData.height;
                tempCanvas.getContext('2d').putImageData(imageData, 0, 0);
                return tempCanvas.toDataURL(); // PNG Data URL
            });

            const projectData = {
                version: 2, // Increment version for new features
                canvasWidth: canvas.width,
                canvasHeight: canvas.height,
                backgroundColor: backgroundColor,
                backgroundImage: backgroundImage ? backgroundImage.src : null, // Save BG image as Data URL
                fps: fps,
                frames: serializableFrames
            };

            const jsonString = JSON.stringify(projectData);
            const blob = new Blob([jsonString], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `animation_${Date.now()}.animproj`;
            a.click();
            URL.revokeObjectURL(url);
            console.log("Project saved.");
        }

        function loadProject(file) {
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const projectData = JSON.parse(e.target.result);
                    if (!projectData || (projectData.version !== 1 && projectData.version !== 2)) {
                         throw new Error("Invalid or incompatible project file format.");
                    }
                    if (!Array.isArray(projectData.frames) || projectData.frames.length === 0) {
                        throw new Error("Project file contains no frames.");
                    }

                    // Stop playback
                    if (isPlaying) playPauseAnimation();

                    // Apply settings
                    fps = projectData.fps || 12;
                    backgroundColor = projectData.backgroundColor || '#FFFFFF';
                    backgroundImage = null; // Reset first

                    // Resize canvas if needed
                    if (projectData.canvasWidth && projectData.canvasHeight &&
                        (canvas.width !== projectData.canvasWidth || canvas.height !== projectData.canvasHeight)) {
                         canvas.width = projectData.canvasWidth;
                         canvas.height = projectData.canvasHeight;
                         resizeCanvas(); // This triggers redraw logic internally
                     }


                    // Load Background Image (if saved)
                     const bgImagePromise = projectData.backgroundImage ? loadImageFromDataURL(projectData.backgroundImage) : Promise.resolve(null);

                     bgImagePromise.then(img => {
                         backgroundImage = img; // Set loaded background image

                         // Load Frames (after potential resize and background load)
                         frames = []; // Clear existing frames
                         const framePromises = projectData.frames.map(dataUrl => loadImageDataFromDataURL(dataUrl));

                         return Promise.all(framePromises); // Wait for all frames to load
                     })
                    .then(loadedFrames => {
                        frames = loadedFrames.filter(f => f instanceof ImageData);
                        if (frames.length === 0) throw new Error("Could not load any valid frames.");

                         currentFrameIndex = 0;
                         clearUndoStack();
                         loadFrame(currentFrameIndex); // Load first frame onto canvas
                         updateTimeline(); // Update timeline UI
                         setupUI(); // Reset UI elements to loaded state (pickers, etc.)
                         console.log("Project loaded successfully.");
                    })
                    .catch(error => {
                         console.error("Error during project load:", error);
                         alert(`Failed to load project: ${error.message}`);
                         // Optionally reset to default state
                         // initialize();
                     });

                } catch (error) {
                    console.error("Error parsing project file:", error);
                    alert("Failed to load project file. It might be invalid or corrupted.\nError: " + error.message);
                }
            };
            reader.onerror = () => alert("Failed to read the project file.");
            reader.readAsText(file);
        }

         // Helper to load an Image object from Data URL
         function loadImageFromDataURL(dataURL) {
              return new Promise((resolve, reject) => {
                  const img = new Image();
                  img.onload = () => resolve(img);
                  img.onerror = () => {
                      console.error("Failed to load image from DataURL:", dataURL.substring(0, 50) + "...");
                      resolve(null); // Resolve null on error
                  };
                  img.src = dataURL;
              });
         }


        // Helper to convert Data URL back to ImageData
        function loadImageDataFromDataURL(dataURL) {
             return new Promise((resolve) => { // Removed reject, just resolve null on error
                 const img = new Image();
                 img.onload = () => {
                      // Ensure temp canvas matches loaded image dimensions
                      const tempCanvas = document.createElement('canvas');
                      tempCanvas.width = img.naturalWidth;
                      tempCanvas.height = img.naturalHeight;
                      const tempCtx = tempCanvas.getContext('2d');
                      tempCtx.drawImage(img, 0, 0);
                      // Get ImageData *from the temp canvas*
                      resolve(tempCtx.getImageData(0, 0, img.naturalWidth, img.naturalHeight));
                 };
                 img.onerror = () => {
                      console.error("Failed to load image for ImageData:", dataURL.substring(0, 50) + "...");
                      resolve(null); // Resolve null so Promise.all doesn't fail completely
                 };
                 img.src = dataURL;
             });
        }


        // --- Video Export (MediaRecorder) ---
        function exportVideo() {
             if (isPlaying) {
                 alert("Please pause the animation before exporting."); return;
             }
             if (frames.length === 0) {
                 alert("No frames to export."); return;
             }

             // Check for MediaRecorder support
             if (typeof MediaRecorder === 'undefined' || !canvas.captureStream) {
                 alert("Video recording is not supported by your browser."); return;
             }

             const exportButton = document.getElementById('export-video-button');
             const statusDiv = document.getElementById('export-status');
             exportButton.disabled = true;
             exportButton.textContent = '🎬 Recording...';
             statusDiv.textContent = 'Starting export...';
             disableControls(); // Disable other controls

             recordedChunks = []; // Reset chunk array
             const stream = canvas.captureStream(fps); // Capture at target FPS

             // Try common MIME types
             const mimeTypes = [
                 'video/webm;codecs=vp9',
                 'video/webm;codecs=vp8',
                 'video/webm',
                 'video/mp4' // Less likely to be supported directly for canvas recording
             ];
             const supportedMimeType = mimeTypes.find(type => MediaRecorder.isTypeSupported(type));

             if (!supportedMimeType) {
                 alert("No supported video format found for recording (WebM/VP9/VP8 preferred).");
                 enableControls();
                 exportButton.disabled = false;
                 exportButton.textContent = '🎬 Export Video';
                 statusDiv.textContent = '';
                 return;
             }

             console.log("Using MIME type:", supportedMimeType);
             mediaRecorder = new MediaRecorder(stream, { mimeType: supportedMimeType });

             mediaRecorder.ondataavailable = (event) => {
                 if (event.data.size > 0) {
                     recordedChunks.push(event.data);
                 }
             };

             mediaRecorder.onstop = () => {
                 const blob = new Blob(recordedChunks, { type: supportedMimeType });
                 const url = URL.createObjectURL(blob);
                 const a = document.createElement("a");
                 const fileExtension = supportedMimeType.includes('mp4') ? 'mp4' : 'webm';
                 a.href = url;
                 a.download = `animation_${Date.now()}.${fileExtension}`;
                 a.click();
                 URL.revokeObjectURL(url);

                 // Cleanup and UI reset
                 stream.getTracks().forEach(track => track.stop()); // Stop stream tracks
                 mediaRecorder = null;
                 recordedChunks = [];
                 enableControls();
                 exportButton.disabled = false;
                 exportButton.textContent = '🎬 Export Video';
                 statusDiv.textContent = 'Export complete!';
                 setTimeout(() => statusDiv.textContent = '', 3000); // Clear status after a delay
                 loadFrame(currentFrameIndex); // Restore editor view to current frame
                 setActiveFrame(currentFrameIndex);
                 console.log("Recording stopped, video saved.");
             };

             mediaRecorder.onerror = (event) => {
                 console.error("MediaRecorder Error:", event.error);
                 alert(`Video recording failed: ${event.error.name}`);
                 // Cleanup on error
                  if (stream) stream.getTracks().forEach(track => track.stop());
                  mediaRecorder = null;
                  recordedChunks = [];
                  enableControls();
                  exportButton.disabled = false;
                  exportButton.textContent = '🎬 Export Video';
                  statusDiv.textContent = 'Export failed.';
             };

             // Start Recording Process
             mediaRecorder.start();
             console.log("Recording started.");
             let frameToRecord = 0;
             const recordInterval = setInterval(() => {
                 if (frameToRecord < frames.length) {
                     statusDiv.textContent = `Recording frame ${frameToRecord + 1} / ${frames.length}...`;
                     loadFrame(frameToRecord); // Load frame onto canvas for capture
                     // captureStream handles timing based on FPS, just need to ensure frame is drawn
                     frameToRecord++;
                 } else {
                     clearInterval(recordInterval);
                     if (mediaRecorder && mediaRecorder.state === "recording") {
                         mediaRecorder.stop(); // Stop recording after last frame
                     }
                 }
             }, 1000 / fps); // Interval matches FPS to ensure frames are drawn in time

        }


        // --- Event Listeners Setup ---
        function setupEventListeners() {
            // Canvas Mouse Events
             canvas.addEventListener('mousedown', startAction);
             canvas.addEventListener('mousemove', performAction);
             canvas.addEventListener('mouseup', endAction);
             canvas.addEventListener('mouseleave', endAction); // Stop if mouse leaves canvas

             // Canvas Touch Events
             canvas.addEventListener('touchstart', startAction, { passive: false });
             canvas.addEventListener('touchmove', performAction, { passive: false });
             canvas.addEventListener('touchend', endAction);
             canvas.addEventListener('touchcancel', endAction);

            // Toolbar: Tool Selection
            document.querySelectorAll('.tool').forEach(button => {
                button.addEventListener('click', (e) => {
                    document.querySelector('.tool.active').classList.remove('active');
                    const targetButton = e.currentTarget; // Use currentTarget
                    targetButton.classList.add('active');
                    currentTool = targetButton.id.replace('-tool', '');
                    canvas.style.cursor = (currentTool === 'pen' || currentTool === 'eraser') ? 'crosshair' : (currentTool === 'paint-bucket' ? 'copy' : 'default');
                    if (currentTool !== 'select') clearSelectionRectangle(); // Clear selection when switching away
                });
            });

             // Toolbar: Options
             document.getElementById('color-picker').addEventListener('input', (e) => currentColor = e.target.value); // Use 'input' for live updates
             document.getElementById('brush-size').addEventListener('input', (e) => {
                 brushSize = e.target.value;
                 document.getElementById('brush-size-label').textContent = brushSize;
             });

             // Toolbar: Undo
             document.getElementById('undo-button').addEventListener('click', undo);

             // Toolbar: Playback & Export
             document.getElementById('play-pause-button').addEventListener('click', playPauseAnimation);
             document.getElementById('fps-input').addEventListener('change', (e) => updateFps(e.target.value));
             document.getElementById('export-video-button').addEventListener('click', exportVideo);

             // Toolbar: Background
             document.getElementById('set-bg-color').addEventListener('click', () => setBackgroundColor(document.getElementById('bg-color-picker').value));
             document.getElementById('bg-image-upload').addEventListener('change', (e) => { if (e.target.files?.[0]) setBackgroundImage(e.target.files[0]); e.target.value = null; });

             // Toolbar: File Operations
             document.getElementById('save-button').addEventListener('click', saveProject);
             document.getElementById('load-input').addEventListener('change', (e) => { if (e.target.files?.[0]) loadProject(e.target.files[0]); e.target.value = null; });
             document.getElementById('import-image-upload').addEventListener('change', (e) => { if (e.target.files?.[0]) importImage(e.target.files[0]); e.target.value = null; });

             // Toolbar: Onion Skin
             document.getElementById('onion-skin-before').addEventListener('change', (e) => { onionSkinBefore = Math.max(0, parseInt(e.target.value) || 0); drawOnionSkins(); });
             document.getElementById('onion-skin-after').addEventListener('change', (e) => { onionSkinAfter = Math.max(0, parseInt(e.target.value) || 0); drawOnionSkins(); });

             // Timeline Controls
             document.getElementById('add-frame-button').addEventListener('click', addFrame);
             document.getElementById('duplicate-frame-button').addEventListener('click', duplicateFrame);
             document.getElementById('delete-frame-button').addEventListener('click', () => deleteFrame(currentFrameIndex)); // Delete currently selected

             // Window Resize
             window.addEventListener('resize', resizeCanvas); // Use resizeCanvas directly

             // Keyboard Shortcuts (Basic Example)
             window.addEventListener('keydown', (e) => {
                // Allow shortcuts only when not typing in input fields
                if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;

                let handled = true;
                switch (e.key.toLowerCase()) {
                    case 'p': currentTool = 'pen'; break;
                    case 'e': currentTool = 'eraser'; break;
                    case 'b': currentTool = 'paint-bucket'; break;
                    case 's': currentTool = 'select'; break;
                     case 'z': if (e.ctrlKey || e.metaKey) undo(); break; // Ctrl/Cmd + Z
                    default: handled = false;
                 }

                 if (handled) {
                     e.preventDefault(); // Prevent default browser actions (like saving page with Ctrl+S)
                     // Update UI to reflect tool change
                     document.querySelectorAll('.tool').forEach(btn => btn.classList.remove('active'));
                     const toolButton = document.getElementById(`${currentTool}-tool`);
                     if (toolButton) toolButton.classList.add('active');
                     canvas.style.cursor = (currentTool === 'pen' || currentTool === 'eraser') ? 'crosshair' : (currentTool === 'paint-bucket' ? 'copy' : 'default');
                     if (currentTool !== 'select') clearSelectionRectangle();
                 }
             });
        }

        // --- Start ---
        window.onload = initialize;

    </script>

</body>
</html>
